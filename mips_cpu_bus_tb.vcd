$date
	Tue Dec  8 23:24:12 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module mips_cpu_bus_tb $end
$var wire 32 ! writedata [31:0] $end
$var wire 1 " write $end
$var wire 32 # register_v0 [31:0] $end
$var wire 32 $ readdata [31:0] $end
$var wire 1 % read $end
$var wire 4 & byteenable [3:0] $end
$var wire 32 ' address [31:0] $end
$var wire 1 ( active $end
$var reg 1 ) clk $end
$var reg 32 * delayed_readdata [31:0] $end
$var reg 1 + reset $end
$var reg 1 , waitrequest $end
$scope module cpuInst $end
$var wire 1 ) clk $end
$var wire 32 - readdata [31:0] $end
$var wire 1 + reset $end
$var wire 1 , waitrequest $end
$var wire 32 . writedata [31:0] $end
$var wire 32 / register_v0 [31:0] $end
$var wire 32 0 instr_addr [31:0] $end
$var wire 1 1 data_write $end
$var wire 1 2 data_read_en $end
$var wire 32 3 data_addr [31:0] $end
$var wire 1 ( active $end
$var reg 32 4 address [31:0] $end
$var reg 4 5 byteenable [3:0] $end
$var reg 1 6 clk_enable $end
$var reg 32 7 data_read [31:0] $end
$var reg 32 8 data_reg [31:0] $end
$var reg 32 9 instr_addr_reg [31:0] $end
$var reg 32 : instr_read [31:0] $end
$var reg 32 ; instr_reg [31:0] $end
$var reg 2 < next_state [1:0] $end
$var reg 1 % read $end
$var reg 2 = state [1:0] $end
$var reg 1 " write $end
$scope module harvard_cpu $end
$var wire 1 ) clk $end
$var wire 1 6 clk_enable $end
$var wire 32 > data_readdata [31:0] $end
$var wire 32 ? instr_readdata [31:0] $end
$var wire 1 + reset $end
$var wire 1 @ zero $end
$var wire 32 A register_v0 [31:0] $end
$var wire 32 B read_data_b [31:0] $end
$var wire 32 C read_data_a [31:0] $end
$var wire 1 D negative $end
$var wire 1 E equal $end
$var wire 32 F alu_result [31:0] $end
$var reg 1 ( active $end
$var reg 32 G alu_b [31:0] $end
$var reg 4 H alu_control [3:0] $end
$var reg 5 I alu_shift_amt [4:0] $end
$var reg 32 J data_address [31:0] $end
$var reg 1 2 data_read $end
$var reg 1 1 data_write $end
$var reg 32 K data_writedata [31:0] $end
$var reg 32 L hi_in [31:0] $end
$var reg 32 M hi_reg [31:0] $end
$var reg 32 N instr_address [31:0] $end
$var reg 32 O ir_reg [31:0] $end
$var reg 32 P lo_in [31:0] $end
$var reg 32 Q lo_reg [31:0] $end
$var reg 32 R pc_in [31:0] $end
$var reg 32 S pc_reg [31:0] $end
$var reg 64 T product [63:0] $end
$var reg 32 U quotient [31:0] $end
$var reg 5 V regfile_write_addr [4:0] $end
$var reg 32 W regfile_write_data [31:0] $end
$var reg 1 X regfile_write_enable $end
$var reg 32 Y remainder [31:0] $end
$scope module alu $end
$var wire 32 Z alu_b [31:0] $end
$var wire 4 [ alu_control [3:0] $end
$var wire 5 \ alu_shift_amt [4:0] $end
$var wire 32 ] alu_a [31:0] $end
$var reg 32 ^ alu_out [31:0] $end
$var reg 1 E equal $end
$var reg 1 D negative $end
$var reg 1 @ zero $end
$upscope $end
$scope module reg_file $end
$var wire 1 ) clk $end
$var wire 1 6 clk_enable $end
$var wire 5 _ read_addr_a [4:0] $end
$var wire 5 ` read_addr_b [4:0] $end
$var wire 5 a regfile_write_addr [4:0] $end
$var wire 32 b regfile_write_data [31:0] $end
$var wire 1 X regfile_write_enable $end
$var wire 1 + reset $end
$var reg 32 c read_data_a [31:0] $end
$var reg 32 d read_data_b [31:0] $end
$var reg 32 e register_v0 [31:0] $end
$var integer 32 f i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module ramInst $end
$var wire 32 g address [31:0] $end
$var wire 4 h byteenable [3:0] $end
$var wire 1 ) clk $end
$var wire 1 % read $end
$var wire 1 , waitrequest $end
$var wire 1 " write $end
$var wire 32 i writedata [31:0] $end
$var reg 13 j mapped_address [12:0] $end
$var reg 32 k readdata [31:0] $end
$scope begin $unm_blk_1 $end
$var integer 32 l i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000000000000 l
bx k
bx00 j
bx i
b1111 h
bx00 g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
b0 [
bx Z
bx Y
xX
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx00 J
bx I
b0 H
bx G
bx F
xE
xD
bx C
bx B
bx A
x@
bx ?
bx >
bx =
b11 <
bx ;
bx :
bx 9
bx 8
bx 7
16
b1111 5
bx00 4
bx00 3
x2
x1
bx 0
bx /
bx .
bx -
0,
0+
bx *
0)
x(
bx00 '
b1111 &
0%
bx $
bx #
0"
bx !
$end
#10
b0 !
b0 .
b0 K
b0 i
b0 T
0D
1@
b0 B
b0 d
b0 C
b0 ]
b0 c
b0 #
b0 /
b0 A
b0 e
1(
b11 =
1+
1)
#20
0)
#30
b0 W
b0 b
b0 3
b0 J
1E
b0 F
b0 ^
b0 G
b0 Z
1,
b1010000000000 j
06
b0 7
b0 >
b0 :
b0 ?
1%
b10111111110000000000000000000000 '
b10111111110000000000000000000000 4
b10111111110000000000000000000000 g
b10 <
b0 _
b0 `
b111 H
b111 [
b0 P
b0 L
b10111111110000000000000000000100 R
1X
b0 V
b0 a
02
01
b0 T
b0 I
b0 \
b10111111110000000000000000000000 0
b10111111110000000000000000000000 N
0D
1@
b0 B
b0 d
b0 C
b0 ]
b0 c
0+
b0 9
b0 8
b0 ;
b0 Q
b0 M
b0 O
b10111111110000000000000000000000 S
b100000 f
1)
#40
0)
#50
1)
#55
b100100011000110000000001010000 $
b100100011000110000000001010000 k
0,
#60
0)
#70
b0 j
16
bx :
bx ?
0%
b0 '
b0 4
b0 g
b11 <
b10 =
b10111111110000000000000000000000 9
1)
#80
0)
#90
xD
x@
bx W
bx b
bx !
bx .
bx K
bx i
bx T
bx00 3
bx00 J
1,
b1010000000100 j
bx B
bx d
bx C
bx ]
bx c
xE
bx F
bx ^
06
1%
b10111111110000000000000000000100 '
b10111111110000000000000000000100 4
b10111111110000000000000000000100 g
b10 <
bx _
bx `
b10111111110000000000000000001000 R
b0 H
b0 [
xX
bx V
bx a
bx G
bx Z
x2
x1
bx I
bx \
b10111111110000000000000000000100 0
b10111111110000000000000000000100 N
bx O
b10111111110000000000000000000100 S
b11 =
bx ;
1)
#100
0)
#110
1)
#115
b111000011000100000000000011110 $
b111000011000100000000000011110 k
0,
b100100011000110000000001010000 *
b100100011000110000000001010000 -
#120
0)
#130
bx00 j
16
b100100011000110000000001010000 :
b100100011000110000000001010000 ?
0%
bx00 '
bx00 4
bx00 g
b11 <
b10 =
b10111111110000000000000000000100 9
1)
#140
0)
#150
b1010000 W
b1010000 b
b0 !
b0 .
b0 K
b0 i
b0 T
b1010000 3
b1010000 J
0D
0E
1@
b1010000 F
b1010000 ^
bx *
bx -
1,
b1010000001000 j
b0 B
b0 d
b0 C
b0 ]
b0 c
06
1%
b10111111110000000000000000001000 '
b10111111110000000000000000001000 4
b10111111110000000000000000001000 g
b10 <
b11 _
b11 `
b10111111110000000000000000001100 R
1X
b11 V
b11 a
b1010000 G
b1010000 Z
02
01
b1 I
b1 \
b10111111110000000000000000001000 0
b10111111110000000000000000001000 N
b11 =
b100100011000110000000001010000 ;
b100100011000110000000001010000 O
b10111111110000000000000000001000 S
1)
#160
0)
#170
1)
#175
b1000 $
b1000 k
0,
b111000011000100000000000011110 *
b111000011000100000000000011110 -
#180
0)
#190
b1010000 j
16
b111000011000100000000000011110 :
b111000011000100000000000011110 ?
0%
b1010000 '
b1010000 4
b1010000 g
b11 <
b10 =
b10111111110000000000000000001000 9
1)
#200
0)
#210
bx *
bx -
1,
b1010000001100 j
b1001110 W
b1001110 b
b1001100 3
b1001100 J
06
1%
b10111111110000000000000000001100 '
b10111111110000000000000000001100 4
b10111111110000000000000000001100 g
b10 <
0@
b1001110 F
b1001110 ^
b1010000 C
b1010000 ]
b1010000 c
b10 `
b10111111110000000000000000010000 R
b100 H
b100 [
b10 V
b10 a
b11110 G
b11110 Z
b0 I
b0 \
b10111111110000000000000000001100 0
b10111111110000000000000000001100 N
b111000011000100000000000011110 O
b10111111110000000000000000001100 S
b11 =
b111000011000100000000000011110 ;
1)
#220
0)
#230
1)
#235
b0 $
b0 k
0,
b1000 *
b1000 -
#240
0)
#250
b1001100 j
16
b1000 :
b1000 ?
0%
b1001100 '
b1001100 4
b1001100 g
b11 <
b10 =
b10111111110000000000000000001100 9
1)
#260
0)
#270
1E
1@
b0 W
b0 b
b0 3
b0 J
bx *
bx -
1,
b1010000010000 j
b0 C
b0 ]
b0 c
b0 F
b0 ^
06
1%
b10111111110000000000000000010000 '
b10111111110000000000000000010000 4
b10111111110000000000000000010000 g
b10 <
b0 _
b0 `
b0 H
b0 [
b0 R
0X
b0 V
b0 a
b0 G
b0 Z
bx Y
bx U
b0 T
b10111111110000000000000000010000 0
b10111111110000000000000000010000 N
b0 B
b0 d
b1001110 #
b1001110 /
b1001110 A
b1001110 e
b11 =
b1000 ;
b1000 O
b10111111110000000000000000010000 S
1)
#280
0)
#290
1)
#295
0,
b0 *
b0 -
#300
0)
#310
b0 j
16
b0 :
b0 ?
0%
b0 '
b0 4
b0 g
b11 <
b10 =
b10111111110000000000000000010000 9
1)
#320
0)
#330
bx *
bx -
1,
06
1%
b10 <
b111 H
b111 [
b100 R
b0 0
b0 N
0(
b0 O
b0 S
b11 =
b0 ;
1)
#340
0)
#350
1)
