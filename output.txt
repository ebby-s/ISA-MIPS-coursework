addiu1 addiu Pass Addition 
addiu2 addiu Pass pos and neg addition 
addiu3 addiu Pass Testing max range
addiu4 addiu Pass two negatives 
addiu5 addiu Pass loading from different registers
lui1 lui Pass Normal operation
lui2 lui Pass checking immediate is not sign extented
lui3 lui Pass Check if all bits are used
lw1 lw Pass basic
lw2 lw Pass testing a regular load word
lw3 lw Pass load word with a value output
lwl1 lwl Pass Load the lsB as msB
lwl2 lwl Pass Load 2 least significant bytes
lwl3 lwl Pass Load 3 least significant bytes
lwl4 lwl Pass Load a full word
lwr1 lwr Pass Load the full word
lwr2 lwr Pass Load 3 most significant bytes
lwr3 lwr Pass Load 2 most significant bytes
lwr4 lwr Pass Load the msB as the lsB
slti1 slti Pass regular test
slti2 slti Pass both numbers equal
slti3 slti Pass negative numbers
sltiu1 sltiu Pass regular test
sltiu2 sltiu Pass both numbers equal
sltiu3 sltiu Pass negative numbers unsigned 
addu1 addu Pass simple addition
addu2 addu Pass addition
addu3 addu Pass pos and neg addition
addu4 addu Pass neg and neg addition
addu5 addu Pass Same register
and1 and Pass bitwise AND
and2 and Pass and with 0
and3 and Pass and neg value
and4 and Pass and all 1s
andi1 andi Pass bitwise AND immediate
andi2 andi Pass sign extension
andi3 andi Pass sign extension test 2
bne1 bne Pass Normal branch operation
bne2 bne Pass Normal dont branch operation
bne3 bne Pass negative branch
bne4 bne Pass not loading values into registers
j1 j Pass jump halt
j2 j Pass jump to skip an instruction
jal1 jal Pass jump to skip an instruction
jal2 jal Pass link test
jalr1 jalr Pass jalr halt
jalr2 jalr Pass jalr halt
jalr3 jalr Pass jalr delay slot
lb1 lb Pass normal operation loading LSB byte 
lb2 lb Pass normal operation loading 2nd byte 
lb3 lb Pass normal operation loading 3rd byte 
lb4 lb Pass normal operation loading 4th byte 
lb5 lb Pass sign extention of bits 
lb6 lb Pass negative offsets
lb7 lb Pass Offsetting to following word
lb8 lb Pass loading pre existing value 
lbu1 lbu Pass normal operation loading LSB byte 
lbu2 lbu Pass normal operation loading 2nd byte 
lbu3 lbu Pass normal operation loading 3rd byte 
lbu4 lbu Pass normal operation loading 4th byte 
lbu5 lbu Pass sign extention of bits 
lbu6 lbu Pass negative offsets
lbu7 lbu Pass Offsetting to following word
lbu8 lbu Pass loading pre existing value 
lh1 lh Pass normal operation loading lower half word  
lh2 lh Pass normal operation loading upper half word 
lh3 lh Pass sign extention
lh4 lh Pass negative offset
lh5 lh Pass offsetting to following word
lhu1 lhu Pass normal operation loading lower half word  
lhu2 lhu Pass normal operation loading upper half word 
lhu3 lhu Pass sign extention
lhu4 lhu Pass negative offset
lhu5 lhu Pass offsetting to following word
lw1 lw Pass basic
lw2 lw Pass testing a regular load word
lw3 lw Pass load word with a value output
or1 or Pass normal or
or2 or Pass all 1s
or3 or Pass all 0s
ori1 ori Pass normal ori
ori2 ori Pass ori edge case 0
ori3 ori Pass ori edge case all high
sh1 sh Pass Negative store
sh2 sh Pass Testing the maximum limit of bytes
sh3 sh Pass Testing the maximum limit of bytes
sll1 sll Pass shift left logical
sll2 sll Pass shift left logical
sll3 sll Pass edge case shift
sll4 sll Pass no shift
sll5 sll Pass test shamt size
sllv1 sllv Pass shift left logical variable
sllv2 sllv Pass shift left logical variable
sllv3 sllv Pass shift of 0
sllv4 sllv Pass shift edge case
sllv5 sllv Pass write to shamt register
sllv6 sllv Pass test shamt size
sllv7 sllv Pass write to Rt
slt1 slt Pass Set if less than 
slt2 slt Pass Slt opposite
slt3 slt Pass Slt negative
slt4 slt Pass Slt edge case 1
slt5 slt Pass Slt same number
slti1 slti Pass regular test
slti2 slti Pass both numbers equal
slti3 slti Pass negative numbers
sltiu1 sltiu Pass regular test
sltiu2 sltiu Pass both numbers equal
sltiu3 sltiu Pass negative numbers unsigned 
sltu1 sltu Pass Set if less than unsigned
sltu2 sltu Pass Edge case
sltu3 sltu Pass opposite
sra1 sra Pass shift right word arithmetic
sra2 sra Pass edge case testing sra
sra3 sra Pass edge case testing sra
sra4 sra Pass test shamt size
srav1 srav Pass shift word arithmetic right variable 
srav2 srav Pass edge case testing srav
srav3 srav Pass edge case testing srav
srav4 srav Pass test shamt size
srav5 srav Pass write to shamt register
srav6 srav Pass write to Rt
srl1 srl Pass shift right logical
srl2 srl Pass duo shift right logical
srl3 srl Pass insert zero to negative value
srl4 srl Pass no shift
srl5 srl Pass test shamt size
srlv1 srlv Pass shift right logical variable
srlv2 srlv Pass shift right logical variable & shift by 0
srlv3 srlv Pass insert zero to negative value
srlv4 srlv Pass edge cases for bit shift count 
srlv5 srlv Pass test shamt size
srlv6 srlv Pass Write to shamt register
srlv7 srlv Pass Write to Rt
subu1 subu Pass normal case
subu2 subu Pass pos and neg
subu3 subu Pass neg and pos
subu4 subu Pass sub 0
subu5 subu Pass 0 sub
sw1 sw Pass Simple test
sw2 sw Pass store word repeat store
sw3 sw Pass maximum store
sw4 sw Pass no store
xor1 xor Pass normal case
xor2 xor Pass ones and zeros except lsb
xor3 xor Pass all ones 
xor4 xor Pass all zeros bar 1
xori1 xori Pass normal case
xori2 xori Pass edge case
xori3 xori Pass edge case 2
beq1 beq Pass Branch should be taken
beq2 beq Pass Branch should not take
beq3 beq Pass signed offset
beq4 beq Pass branch to itself no infinite loop
bgez1 bgez Pass branch greater
bgez2 bgez Pass branching equal
bgez3 bgez Pass dont branch
bgez4 bgez Pass loop using delay slot
bgez5 bgez Pass big branch
bgezal1 bgezal Pass branch greater and link
bgezal2 bgezal Pass branching and link equal to 0
bgezal3 bgezal Pass dont branch and link
bgezal4 bgezal Pass dont branch and link
bgezal5 bgezal Pass branch and link register test
bgtz1 bgtz Pass branch greater than 0
bgtz2 bgtz Pass branching equal testcase
bgtz3 bgtz Pass negative input to register
bgtz4 bgtz Pass repeated branch
blez1 blez Pass branch less than
blez2 blez Pass branching equal
blez3 blez Pass dont branch
blez4 blez Pass repeated branch
bltz1 bltz Pass branch less than
bltz2 bltz Pass branching equal
bltz3 bltz Pass dont branch
bltz4 bltz Pass repeated branch
bltzal1 bltzal Pass branch less than
bltzal2 bltzal Pass branching equal
bltzal3 bltzal Pass dont branch
bltzal4 bltzal Pass repeated branch
bltzal5 bltzal Pass branch and link register test
div1 div Pass normal 8 divide 4, quotient 
div2 div Pass normal 8 divide 4, remainder 
div3 div Pass negative divide test case
div4 div Pass double negative divide test case
divu1 divu Pass normal 16 divide usigned 4, quotient 
divu2 divu Pass normal 16 divide unsigned 4, remainder 
divu3 divu Pass negative divide unsigned test case
divu4 divu Pass double negative divide unsigned test case 
jr1 jr Pass HALT
jr2 jr Pass normal jump register
jr3 jr Pass DT special
mfhi1 mfhi  Pass Normal operation using MULT
mflo1 mflo  Pass Normal operation using MULT
mthi1 mthi Pass regular move to hi
mthi2 mthi Pass regular move to hi
mthi3 mthi Pass moving 0
mtlo1 mtlo Pass normal move to lo
mtlo2 mtlo Pass regular move to lo
mtlo3 mtlo Pass regular move to lo
mult1 mult Pass normal 4 multiply 5 
mult2 mult Pass normal 4 multiply 5 hi reg check
mult3 mult Pass multiply by 0
mult4 mult Pass multiply -1 by 6 lo reg check
mult5 mult Pass multiply unsigned -1 by 6 hi reg check
multu1 multu Pass normal 5 multiply 6
multu2 multu Pass normal 4 multiply unsigned 5 hi reg check
multu3 multu Pass multiply by 0
multu4 multu Pass multiply unsigned -1 by 6 lo reg check
multu5 multu Pass multiply unsigned -1 by 6 hi reg check
sb1 sb Pass Negative store
sb2 sb Pass Testing the maximum limit of bytes
fib1 sw Pass fibonacci(20)
str-len1 addiu Pass string length
